import { pgTable, uuid, text, timestamp, integer, jsonb, boolean, decimal } from 'drizzle-orm/pg-core';

// User table with auth and role support
export const user = pgTable('user', {
	id: text('id').primaryKey(), // UUID generated by Lucia or your auth flow

	email: text('email').notNull().unique(),
	hashedPassword: text('hashed_password').notNull(), // hashed_password is the DB column, but use camelCase in code

	// User profile
	firstName: text('first_name').notNull(),
	lastName: text('last_name').notNull(),
	gemId: text('gem_id'), // Optional GEM ID for tournament registration

	role: text('role').notNull().default('free'), // Options: 'free', 'premium', 'admin', 'writer', 'tournament_staff'

	// Subscription tracking
	subscriptionId: text('subscription_id'), // Authorize.net subscription ID for premium users

	createdAt: timestamp('created_at', {
		withTimezone: true,
		mode: 'date'
	}).defaultNow()
});

// Session table for Lucia session tracking
export const session = pgTable('session', {
	id: text('id').primaryKey(),

	userId: text('user_id')
		.notNull()
		.references(() => user.id),

	expiresAt: timestamp('expires_at', {
		withTimezone: true,
		mode: 'date'
	}).notNull()
});

// EVENTS
export const event = pgTable('event', {
	id: text('id').primaryKey(), // UUID or slug
	title: text('title').notNull(),
	location: text('location'), // Venue name - nullable for migration compatibility
	address: text('address'), // Physical address of venue
	price: decimal('price', { precision: 10, scale: 2 }).notNull(),
	format: text('format'), // e.g., "Standard", "Modern", "Draft" - nullable for migration
	gemIdRequired: boolean('gem_id_required').default(false),
	circuit: text('circuit'), // e.g., "Los Angeles", "St. Louis", "New England"
	month: text('month'), // e.g., "January", "February", etc.
	eventDate: timestamp('event_date', { withTimezone: true, mode: 'date' }), // Nullable for migration
	description: text('description'),
	premiumDiscount: boolean('premium_discount').default(false), // 10% discount for premium users

	// Event status for closeout workflow
	status: text('status').default('upcoming'), // 'upcoming', 'in_progress', 'completed', 'cancelled'
	closedAt: timestamp('closed_at', { withTimezone: true, mode: 'date' }),
	closedBy: text('closed_by').references(() => user.id),

	createdBy: text('created_by').references(() => user.id),
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// TICKETS
export const ticket = pgTable('ticket', {
	id: uuid('id').defaultRandom().primaryKey(),
	userId: text('user_id').references(() => user.id),
	eventId: text('event_id').notNull().references(() => event.id),
	code: text('code').notNull(),
	quantity: integer('quantity').default(1),

	// Player information
	firstName: text('first_name'), // Player's first name
	lastName: text('last_name'), // Player's last name
	gemId: text('gem_id'), // Gem ID if required by event

	// Payment information
	amountPaid: decimal('amount_paid', { precision: 10, scale: 2 }), // Actual amount paid (with discount if applicable)
	transactionId: text('transaction_id'), // Authorize.net transaction ID

	// Status tracking
	refunded: boolean('refunded').default(false),
	refundedAt: timestamp('refunded_at', { withTimezone: true, mode: 'date' }),
	enteredIntoGem: boolean('entered_into_gem').default(false), // Whether player has been entered into tournament software

	// Timestamps
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow(),
	voidedAt: timestamp('voided_at', { withTimezone: true, mode: 'date' })
});

// ENTITLEMENTS (for courses and digital products)
export const entitlement = pgTable('entitlement', {
	id: uuid('id').defaultRandom().primaryKey(), // <-- uuid + defaultRandom
	userId: text('user_id'),
	product: text('product').notNull(),
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// ORDERS (audit)
export const order = pgTable('order', {
	id: uuid('id').defaultRandom().primaryKey(), // <-- uuid + defaultRandom
	provider: text('provider').notNull(), // 'authnet'
	providerRef: text('provider_ref').notNull(),
	userEmail: text('user_email'),
	amount: text('amount'),
	currency: text('currency'),
	meta: jsonb('meta'),
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// WEBHOOK IDEMPOTENCY
export const webhookEvent = pgTable('webhook_event', {
	id: text('id').primaryKey(), // Auth.Net event id as text (no default)
	provider: text('provider').notNull(),
	receivedAt: timestamp('received_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// PASSWORD RESET TOKENS
export const passwordResetToken = pgTable('password_reset_token', {
	id: text('id').primaryKey(), // Token hash
	userId: text('user_id').notNull().references(() => user.id),
	expiresAt: timestamp('expires_at', { withTimezone: true, mode: 'date' }).notNull(),
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// EVENT STAFF ASSIGNMENTS (for tournament staff)
export const eventStaff = pgTable('event_staff', {
	id: uuid('id').defaultRandom().primaryKey(),
	userId: text('user_id').notNull().references(() => user.id),
	eventId: text('event_id').notNull().references(() => event.id),
	assignedBy: text('assigned_by').references(() => user.id), // Admin who assigned the staff
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// EVENT RESULTS (tournament placements after event closeout)
export const eventResult = pgTable('event_result', {
	id: uuid('id').defaultRandom().primaryKey(),
	eventId: text('event_id').notNull().references(() => event.id),

	// Player identification
	userId: text('user_id').references(() => user.id), // Optional - may not have account
	gemId: text('gem_id'), // GEM ID from tournament software
	playerName: text('player_name').notNull(), // Display name

	// Tournament results
	placement: integer('placement').notNull(), // 1st, 2nd, 3rd, etc.
	wins: integer('wins').default(0),
	losses: integer('losses').default(0),
	draws: integer('draws').default(0),

	// Rewards
	agePoints: integer('age_points').default(0), // Points toward Player's Championship
	prizeAmount: decimal('prize_amount', { precision: 10, scale: 2 }), // Cash prize if any

	// Decklist reference (optional - some players may not submit)
	decklistId: uuid('decklist_id'),

	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// EVENT DECKLISTS (player deck submissions)
export const eventDecklist = pgTable('event_decklist', {
	id: uuid('id').defaultRandom().primaryKey(),
	eventId: text('event_id').notNull().references(() => event.id),

	// Player identification
	userId: text('user_id').references(() => user.id),
	gemId: text('gem_id'),
	playerName: text('player_name').notNull(),

	// Deck information
	deckName: text('deck_name'), // Optional deck name/archetype
	hero: text('hero'), // Hero card for the deck
	format: text('format'), // Format the deck was played in

	// Deck contents - stored as JSON array of card objects
	// Each card: { name: string, quantity: number, type?: string }
	cards: jsonb('cards').notNull(),

	// Visibility
	isPublic: boolean('is_public').default(true), // Whether to show on public results

	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});

// SEASON STANDINGS (circuit leaderboards)
export const seasonStanding = pgTable('season_standing', {
	id: uuid('id').defaultRandom().primaryKey(),

	// Season and circuit info
	season: text('season').notNull(), // e.g., "2025", "2024-2025"
	circuit: text('circuit').notNull(), // "Los Angeles", "St. Louis", "New England"

	// Player identification
	userId: text('user_id').references(() => user.id),
	gemId: text('gem_id'),
	playerName: text('player_name').notNull(),

	// Standing data
	rank: integer('rank'), // Current rank in circuit
	totalPoints: integer('total_points').default(0), // Total AGE points
	eventsPlayed: integer('events_played').default(0),

	// Best finishes
	firstPlaceFinishes: integer('first_place_finishes').default(0),
	top4Finishes: integer('top_4_finishes').default(0),
	top8Finishes: integer('top_8_finishes').default(0),

	// Qualification status
	qualifiedForChampionship: boolean('qualified_for_championship').default(false),

	updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'date' }).defaultNow(),
	createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' }).defaultNow()
});
